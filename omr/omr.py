# -*- coding: utf-8 -*-
"""Copy of Img_sgmnt_new.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c6xezUub4TL4UGDkK0r9zS85yFeNftA8
"""

!pip install --upgrade imutils

!pip install pytesseract

import cv2
from google.colab.patches import cv2_imshow
import imutils

image_path = 'scan0526.jpg'
orig = cv2.imread(image_path)

if orig is None:
    raise FileNotFoundError(f"Gambar '{image_path}' tidak ditemukan!")

image = orig.copy()

image = imutils.resize(image, width=500)
ratio = orig.shape[1] / float(image.shape[1])
x, y, w, h = 0, 240, 500, 110

x_orig = int(x * ratio)
y_orig = int(y * ratio)
w_orig = int(w * ratio)
h_orig = int(h * ratio)

height, width, _ = orig.shape
if x_orig + w_orig > width or y_orig + h_orig > height:
    raise ValueError("Area cropping berada di luar batas gambar.")

cropped_image = orig[y_orig:y_orig + h_orig, x_orig:x_orig + w_orig]

print("Hasil crop:")
cv2_imshow(cropped_image)

output_path = 'image1.jpg'
cv2.imwrite(output_path, cropped_image)
print(f"Hasil cropping disimpan sebagai '{output_path}'")

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

image_path = "image1.jpg"
image = cv2.imread(image_path)
if image is None:
    raise FileNotFoundError("Gambar tidak ditemukan. Periksa path!")

gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

blurred = cv2.GaussianBlur(gray, (5, 5), 0)
edged = cv2.Canny(blurred, 50, 150)

# Find contours
cnts = cv2.findContours(edged.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
cnts = cnts[0] if len(cnts) == 2 else cnts[1]

# Copy the original image to draw contours
output_image = image.copy()

# Initialize a counter for circular contours
circular_contour_count = 0

# Loop over the contours and filter for circular shapes
for i, c in enumerate(cnts):
    # Compute the area and perimeter of the contour
    area = cv2.contourArea(c)
    perimeter = cv2.arcLength(c, True)

    if perimeter == 0:
        continue

    circularity = 4 * np.pi * (area / (perimeter * perimeter))

    if 0.6 < circularity < 1.2 and 150 < area < 1000:
        circular_contour_count += 1
        cv2.drawContours(output_image, [c], -1, (0, 255, 0), 2)

cv2_imshow(output_image)

print(f"Jumlah kontur bulat yang terdeteksi: {circular_contour_count}")

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

image_path = "image1.jpg"
image = cv2.imread(image_path)
if image is None:
    raise FileNotFoundError("Gambar tidak ditemukan")

gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
blurred = cv2.GaussianBlur(gray, (5, 5), 0)
edged = cv2.Canny(blurred, 50, 150)

# contours
cnts = cv2.findContours(edged.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
cnts = cnts[0] if len(cnts) == 2 else cnts[1]

output_image = image.copy()

circle_data = []

for c in cnts:
    area = cv2.contourArea(c)
    perimeter = cv2.arcLength(c, True)
    if perimeter == 0:
        continue

    circularity = 4 * np.pi * (area / (perimeter * perimeter))

    if 0.6 < circularity < 1.2 and 150 < area < 1000:
        M = cv2.moments(c)
        if M["m00"] != 0:
            cx = int(M["m10"] / M["m00"])
            cy = int(M["m01"] / M["m00"])
        else:
            cx, cy = 0, 0
        circle_data.append((area, perimeter, cx, cy, c))

circle_data.sort(reverse=True, key=lambda x: x[0])

for area, perimeter, cx, cy, c in circle_data:
    cv2.drawContours(output_image, [c], -1, (0, 255, 0), 2)

# Detect the filled
filled_circles = []
for area, perimeter, cx, cy, c in circle_data:
    circle_mask = np.zeros_like(gray)
    cv2.drawContours(circle_mask, [c], -1, 255, -1)
    avg_color = cv2.mean(gray, mask=circle_mask)[0]
    if avg_color < 140:
        filled_circles.append((cx, cy))

for cx, cy in filled_circles:
    cv2.circle(output_image, (cx, cy), 10, (0, 0, 255), 4)


cv2_imshow(output_image)

print(f"Jumlah yang terisi: {len(filled_circles)}")

answers = {}
row_group = {}
for area, perimeter, cx, cy, c in circle_data:
    row_key = cy // 0.01
    if row_key not in row_group:
        row_group[row_key] = []
    row_group[row_key].append((cx, cy, c))


for key in row_group:
    row_group[key].sort(key=lambda x: x[0])

filled_circles = []
for row_key, row in row_group.items():
    for i, (cx, cy, c) in enumerate(row):
        circle_mask = np.zeros_like(gray)
        cv2.drawContours(circle_mask, [c], -1, 255, -1)
        avg_color = cv2.mean(gray, mask=circle_mask)[0]
        if avg_color < 140:
            filled_circles.append((row_key, i))

question_number = 1
for row_key, row in sorted(row_group.items()):
    selected_choice = None
    for i, (cx, cy, c) in enumerate(row):
        if (row_key, i) in filled_circles:
            selected_choice = chr(65 + i)
            break
    if selected_choice:
        answers[question_number] = selected_choice
    else:
        answers[question_number] = "0"

    question_number += 1

for area, perimeter, cx, cy, c in circle_data:
    cv2.drawContours(output_image, [c], -1, (0, 255, 0), 2)
for row_key, i in filled_circles:
    cx, cy, c = row_group[row_key][i]
    cv2.drawContours(output_image, [c], -1, (0, 0, 255), 2)

cv2_imshow(output_image)

for question, answer in answers.items():
    print(f"{question}. {answer}")